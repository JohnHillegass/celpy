/*
cgo stubs for package cel.
File is generated by gopy. Do not edit.
gopy pkg github.com/google/cel-go/cel
*/

package main

/*

#cgo CFLAGS: -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7
#cgo LDFLAGS: -L/System/Library/Frameworks/Python.framework/Versions/2.7/lib -lpython2.7 -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common"
	"github.com/google/cel-go/common/types/ref"
	"github.com/google/cel-go/interpreter"
	expr "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// --- generated code for package: cel below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *common.Errors
func ptrFromHandle_Ptr_common_Errors(h CGoHandle) *common.Errors {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*common.Errors")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.Errors{})).(*common.Errors)
}
func handleFromPtr_Ptr_common_Errors(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*common.Errors", p))
}

// Converters for pointer handles for type: *interpreter.AttributePattern
func ptrFromHandle_Ptr_interpreter_AttributePattern(h CGoHandle) *interpreter.AttributePattern {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*interpreter.AttributePattern")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interpreter.AttributePattern{})).(*interpreter.AttributePattern)
}
func handleFromPtr_Ptr_interpreter_AttributePattern(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*interpreter.AttributePattern", p))
}

// Converters for pointer handles for type: *interpreter.AttributeQualifierPattern
func ptrFromHandle_Ptr_interpreter_AttributeQualifierPattern(h CGoHandle) *interpreter.AttributeQualifierPattern {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*interpreter.AttributeQualifierPattern")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interpreter.AttributeQualifierPattern{})).(*interpreter.AttributeQualifierPattern)
}
func handleFromPtr_Ptr_interpreter_AttributeQualifierPattern(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*interpreter.AttributeQualifierPattern", p))
}

// Converters for pointer handles for type: *expr.CheckedExpr
func ptrFromHandle_Ptr_expr_CheckedExpr(h CGoHandle) *expr.CheckedExpr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.CheckedExpr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.CheckedExpr{})).(*expr.CheckedExpr)
}
func handleFromPtr_Ptr_expr_CheckedExpr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.CheckedExpr", p))
}

// Converters for pointer handles for type: *expr.Constant
func ptrFromHandle_Ptr_expr_Constant(h CGoHandle) *expr.Constant {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Constant")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Constant{})).(*expr.Constant)
}
func handleFromPtr_Ptr_expr_Constant(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Constant", p))
}

// Converters for pointer handles for type: *expr.Expr
func ptrFromHandle_Ptr_expr_Expr(h CGoHandle) *expr.Expr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr{})).(*expr.Expr)
}
func handleFromPtr_Ptr_expr_Expr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr", p))
}

// Converters for pointer handles for type: *expr.Expr_Call
func ptrFromHandle_Ptr_expr_Expr_Call(h CGoHandle) *expr.Expr_Call {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Call")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Call{})).(*expr.Expr_Call)
}
func handleFromPtr_Ptr_expr_Expr_Call(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Call", p))
}

// Converters for pointer handles for type: *expr.Expr_Comprehension
func ptrFromHandle_Ptr_expr_Expr_Comprehension(h CGoHandle) *expr.Expr_Comprehension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Comprehension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Comprehension{})).(*expr.Expr_Comprehension)
}
func handleFromPtr_Ptr_expr_Expr_Comprehension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Comprehension", p))
}

// Converters for pointer handles for type: *expr.Expr_CreateList
func ptrFromHandle_Ptr_expr_Expr_CreateList(h CGoHandle) *expr.Expr_CreateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_CreateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateList{})).(*expr.Expr_CreateList)
}
func handleFromPtr_Ptr_expr_Expr_CreateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_CreateList", p))
}

// Converters for pointer handles for type: *expr.Expr_CreateStruct
func ptrFromHandle_Ptr_expr_Expr_CreateStruct(h CGoHandle) *expr.Expr_CreateStruct {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_CreateStruct")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateStruct{})).(*expr.Expr_CreateStruct)
}
func handleFromPtr_Ptr_expr_Expr_CreateStruct(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_CreateStruct", p))
}

// Converters for pointer handles for type: *expr.Expr_CreateStruct_Entry
func ptrFromHandle_Ptr_expr_Expr_CreateStruct_Entry(h CGoHandle) *expr.Expr_CreateStruct_Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_CreateStruct_Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateStruct_Entry{})).(*expr.Expr_CreateStruct_Entry)
}
func handleFromPtr_Ptr_expr_Expr_CreateStruct_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_CreateStruct_Entry", p))
}

// Converters for pointer handles for type: *expr.Expr_Ident
func ptrFromHandle_Ptr_expr_Expr_Ident(h CGoHandle) *expr.Expr_Ident {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Ident")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Ident{})).(*expr.Expr_Ident)
}
func handleFromPtr_Ptr_expr_Expr_Ident(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Ident", p))
}

// Converters for pointer handles for type: *expr.Expr_Select
func ptrFromHandle_Ptr_expr_Expr_Select(h CGoHandle) *expr.Expr_Select {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Select")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Select{})).(*expr.Expr_Select)
}
func handleFromPtr_Ptr_expr_Expr_Select(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Select", p))
}

// Converters for pointer handles for type: *expr.ParsedExpr
func ptrFromHandle_Ptr_expr_ParsedExpr(h CGoHandle) *expr.ParsedExpr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.ParsedExpr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.ParsedExpr{})).(*expr.ParsedExpr)
}
func handleFromPtr_Ptr_expr_ParsedExpr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.ParsedExpr", p))
}

// Converters for pointer handles for type: *expr.Reference
func ptrFromHandle_Ptr_expr_Reference(h CGoHandle) *expr.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Reference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Reference{})).(*expr.Reference)
}
func handleFromPtr_Ptr_expr_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Reference", p))
}

// Converters for pointer handles for type: *expr.SourceInfo
func ptrFromHandle_Ptr_expr_SourceInfo(h CGoHandle) *expr.SourceInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.SourceInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.SourceInfo{})).(*expr.SourceInfo)
}
func handleFromPtr_Ptr_expr_SourceInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.SourceInfo", p))
}

// Converters for pointer handles for type: *expr.Type
func ptrFromHandle_Ptr_expr_Type(h CGoHandle) *expr.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type{})).(*expr.Type)
}
func handleFromPtr_Ptr_expr_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type", p))
}

// Converters for pointer handles for type: *expr.Type_AbstractType
func ptrFromHandle_Ptr_expr_Type_AbstractType(h CGoHandle) *expr.Type_AbstractType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_AbstractType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_AbstractType{})).(*expr.Type_AbstractType)
}
func handleFromPtr_Ptr_expr_Type_AbstractType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_AbstractType", p))
}

// Converters for pointer handles for type: *expr.Type_FunctionType
func ptrFromHandle_Ptr_expr_Type_FunctionType(h CGoHandle) *expr.Type_FunctionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_FunctionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_FunctionType{})).(*expr.Type_FunctionType)
}
func handleFromPtr_Ptr_expr_Type_FunctionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_FunctionType", p))
}

// Converters for pointer handles for type: *expr.Type_ListType
func ptrFromHandle_Ptr_expr_Type_ListType(h CGoHandle) *expr.Type_ListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_ListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_ListType{})).(*expr.Type_ListType)
}
func handleFromPtr_Ptr_expr_Type_ListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_ListType", p))
}

// Converters for pointer handles for type: *expr.Type_MapType
func ptrFromHandle_Ptr_expr_Type_MapType(h CGoHandle) *expr.Type_MapType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_MapType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_MapType{})).(*expr.Type_MapType)
}
func handleFromPtr_Ptr_expr_Type_MapType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_MapType", p))
}

// Converters for pointer handles for type: *expr.Type_PrimitiveType
func ptrFromHandle_Ptr_expr_Type_PrimitiveType(h CGoHandle) *expr.Type_PrimitiveType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_PrimitiveType")
	if p == nil {
		return nil
	}
	return p.(*expr.Type_PrimitiveType)
}
func handleFromPtr_Ptr_expr_Type_PrimitiveType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_PrimitiveType", p))
}

// Converters for pointer handles for type: *expr.Type_WellKnownType
func ptrFromHandle_Ptr_expr_Type_WellKnownType(h CGoHandle) *expr.Type_WellKnownType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_WellKnownType")
	if p == nil {
		return nil
	}
	return p.(*expr.Type_WellKnownType)
}
func handleFromPtr_Ptr_expr_Type_WellKnownType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_WellKnownType", p))
}

// Converters for pointer handles for type: *durationpb.Duration
func ptrFromHandle_Ptr_durationpb_Duration(h CGoHandle) *durationpb.Duration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*durationpb.Duration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(durationpb.Duration{})).(*durationpb.Duration)
}
func handleFromPtr_Ptr_durationpb_Duration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*durationpb.Duration", p))
}

// Converters for pointer handles for type: *emptypb.Empty
func ptrFromHandle_Ptr_emptypb_Empty(h CGoHandle) *emptypb.Empty {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*emptypb.Empty")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(emptypb.Empty{})).(*emptypb.Empty)
}
func handleFromPtr_Ptr_emptypb_Empty(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*emptypb.Empty", p))
}

// Converters for pointer handles for type: *structpb.NullValue
func ptrFromHandle_Ptr_structpb_NullValue(h CGoHandle) *structpb.NullValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*structpb.NullValue")
	if p == nil {
		return nil
	}
	return p.(*structpb.NullValue)
}
func handleFromPtr_Ptr_structpb_NullValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*structpb.NullValue", p))
}

// Converters for pointer handles for type: *timestamppb.Timestamp
func ptrFromHandle_Ptr_timestamppb_Timestamp(h CGoHandle) *timestamppb.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*timestamppb.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(timestamppb.Timestamp{})).(*timestamppb.Timestamp)
}
func handleFromPtr_Ptr_timestamppb_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*timestamppb.Timestamp", p))
}

// Converters for non-pointer handles for type: common.Error
func ptrFromHandle_common_Error(h CGoHandle) *common.Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "common.Error")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.Error{})).(*common.Error)
}
func handleFromPtr_common_Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("common.Error", p))
}

// Converters for non-pointer handles for type: *common.Errors
func ptrFromHandle_common_Errors(h CGoHandle) *common.Errors {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*common.Errors")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.Errors{})).(*common.Errors)
}
func handleFromPtr_common_Errors(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*common.Errors", p))
}

// Converters for pointer handles for type: common.Location
func ptrFromHandle_common_Location(h CGoHandle) common.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "common.Location")
	if p == nil {
		return nil
	}
	return p.(common.Location)
}
func handleFromPtr_common_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("common.Location", p))
}

// Converters for pointer handles for type: common.Source
func ptrFromHandle_common_Source(h CGoHandle) common.Source {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "common.Source")
	if p == nil {
		return nil
	}
	return p.(common.Source)
}
func handleFromPtr_common_Source(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("common.Source", p))
}

// Converters for pointer handles for type: ref.TypeAdapter
func ptrFromHandle_ref_TypeAdapter(h CGoHandle) ref.TypeAdapter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ref.TypeAdapter")
	if p == nil {
		return nil
	}
	return p.(ref.TypeAdapter)
}
func handleFromPtr_ref_TypeAdapter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ref.TypeAdapter", p))
}

// Converters for pointer handles for type: ref.TypeProvider
func ptrFromHandle_ref_TypeProvider(h CGoHandle) ref.TypeProvider {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ref.TypeProvider")
	if p == nil {
		return nil
	}
	return p.(ref.TypeProvider)
}
func handleFromPtr_ref_TypeProvider(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ref.TypeProvider", p))
}

// Converters for pointer handles for type: interpreter.Activation
func ptrFromHandle_interpreter_Activation(h CGoHandle) interpreter.Activation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interpreter.Activation")
	if p == nil {
		return nil
	}
	return p.(interpreter.Activation)
}
func handleFromPtr_interpreter_Activation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interpreter.Activation", p))
}

// Converters for non-pointer handles for type: *interpreter.AttributePattern
func ptrFromHandle_interpreter_AttributePattern(h CGoHandle) *interpreter.AttributePattern {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*interpreter.AttributePattern")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interpreter.AttributePattern{})).(*interpreter.AttributePattern)
}
func handleFromPtr_interpreter_AttributePattern(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*interpreter.AttributePattern", p))
}

// Converters for non-pointer handles for type: interpreter.AttributeQualifierPattern
func ptrFromHandle_interpreter_AttributeQualifierPattern(h CGoHandle) *interpreter.AttributeQualifierPattern {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interpreter.AttributeQualifierPattern")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interpreter.AttributeQualifierPattern{})).(*interpreter.AttributeQualifierPattern)
}
func handleFromPtr_interpreter_AttributeQualifierPattern(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interpreter.AttributeQualifierPattern", p))
}

// Converters for pointer handles for type: interpreter.EvalState
func ptrFromHandle_interpreter_EvalState(h CGoHandle) interpreter.EvalState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interpreter.EvalState")
	if p == nil {
		return nil
	}
	return p.(interpreter.EvalState)
}
func handleFromPtr_interpreter_EvalState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interpreter.EvalState", p))
}

// Converters for pointer handles for type: interpreter.PartialActivation
func ptrFromHandle_interpreter_PartialActivation(h CGoHandle) interpreter.PartialActivation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interpreter.PartialActivation")
	if p == nil {
		return nil
	}
	return p.(interpreter.PartialActivation)
}
func handleFromPtr_interpreter_PartialActivation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interpreter.PartialActivation", p))
}

// Converters for pointer handles for type: interpreter.Qualifier
func ptrFromHandle_interpreter_Qualifier(h CGoHandle) interpreter.Qualifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interpreter.Qualifier")
	if p == nil {
		return nil
	}
	return p.(interpreter.Qualifier)
}
func handleFromPtr_interpreter_Qualifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interpreter.Qualifier", p))
}

// Converters for non-pointer handles for type: *expr.CheckedExpr
func ptrFromHandle_expr_CheckedExpr(h CGoHandle) *expr.CheckedExpr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.CheckedExpr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.CheckedExpr{})).(*expr.CheckedExpr)
}
func handleFromPtr_expr_CheckedExpr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.CheckedExpr", p))
}

// Converters for non-pointer handles for type: *expr.Constant
func ptrFromHandle_expr_Constant(h CGoHandle) *expr.Constant {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Constant")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Constant{})).(*expr.Constant)
}
func handleFromPtr_expr_Constant(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Constant", p))
}

// Converters for non-pointer handles for type: *expr.Expr
func ptrFromHandle_expr_Expr(h CGoHandle) *expr.Expr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr{})).(*expr.Expr)
}
func handleFromPtr_expr_Expr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr", p))
}

// Converters for non-pointer handles for type: *expr.Expr_Call
func ptrFromHandle_expr_Expr_Call(h CGoHandle) *expr.Expr_Call {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Call")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Call{})).(*expr.Expr_Call)
}
func handleFromPtr_expr_Expr_Call(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Call", p))
}

// Converters for non-pointer handles for type: *expr.Expr_Comprehension
func ptrFromHandle_expr_Expr_Comprehension(h CGoHandle) *expr.Expr_Comprehension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Comprehension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Comprehension{})).(*expr.Expr_Comprehension)
}
func handleFromPtr_expr_Expr_Comprehension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Comprehension", p))
}

// Converters for non-pointer handles for type: *expr.Expr_CreateList
func ptrFromHandle_expr_Expr_CreateList(h CGoHandle) *expr.Expr_CreateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_CreateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateList{})).(*expr.Expr_CreateList)
}
func handleFromPtr_expr_Expr_CreateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_CreateList", p))
}

// Converters for non-pointer handles for type: *expr.Expr_CreateStruct
func ptrFromHandle_expr_Expr_CreateStruct(h CGoHandle) *expr.Expr_CreateStruct {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_CreateStruct")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateStruct{})).(*expr.Expr_CreateStruct)
}
func handleFromPtr_expr_Expr_CreateStruct(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_CreateStruct", p))
}

// Converters for non-pointer handles for type: expr.Expr_CreateStruct_Entry
func ptrFromHandle_expr_Expr_CreateStruct_Entry(h CGoHandle) *expr.Expr_CreateStruct_Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "expr.Expr_CreateStruct_Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_CreateStruct_Entry{})).(*expr.Expr_CreateStruct_Entry)
}
func handleFromPtr_expr_Expr_CreateStruct_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("expr.Expr_CreateStruct_Entry", p))
}

// Converters for non-pointer handles for type: *expr.Expr_Ident
func ptrFromHandle_expr_Expr_Ident(h CGoHandle) *expr.Expr_Ident {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Ident")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Ident{})).(*expr.Expr_Ident)
}
func handleFromPtr_expr_Expr_Ident(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Ident", p))
}

// Converters for non-pointer handles for type: *expr.Expr_Select
func ptrFromHandle_expr_Expr_Select(h CGoHandle) *expr.Expr_Select {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Expr_Select")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Expr_Select{})).(*expr.Expr_Select)
}
func handleFromPtr_expr_Expr_Select(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Expr_Select", p))
}

// Converters for non-pointer handles for type: *expr.ParsedExpr
func ptrFromHandle_expr_ParsedExpr(h CGoHandle) *expr.ParsedExpr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.ParsedExpr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.ParsedExpr{})).(*expr.ParsedExpr)
}
func handleFromPtr_expr_ParsedExpr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.ParsedExpr", p))
}

// Converters for non-pointer handles for type: expr.Reference
func ptrFromHandle_expr_Reference(h CGoHandle) *expr.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "expr.Reference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Reference{})).(*expr.Reference)
}
func handleFromPtr_expr_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("expr.Reference", p))
}

// Converters for non-pointer handles for type: *expr.SourceInfo
func ptrFromHandle_expr_SourceInfo(h CGoHandle) *expr.SourceInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.SourceInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.SourceInfo{})).(*expr.SourceInfo)
}
func handleFromPtr_expr_SourceInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.SourceInfo", p))
}

// Converters for non-pointer handles for type: *expr.Type
func ptrFromHandle_expr_Type(h CGoHandle) *expr.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type{})).(*expr.Type)
}
func handleFromPtr_expr_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type", p))
}

// Converters for non-pointer handles for type: *expr.Type_AbstractType
func ptrFromHandle_expr_Type_AbstractType(h CGoHandle) *expr.Type_AbstractType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_AbstractType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_AbstractType{})).(*expr.Type_AbstractType)
}
func handleFromPtr_expr_Type_AbstractType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_AbstractType", p))
}

// Converters for non-pointer handles for type: *expr.Type_FunctionType
func ptrFromHandle_expr_Type_FunctionType(h CGoHandle) *expr.Type_FunctionType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_FunctionType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_FunctionType{})).(*expr.Type_FunctionType)
}
func handleFromPtr_expr_Type_FunctionType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_FunctionType", p))
}

// Converters for non-pointer handles for type: *expr.Type_ListType
func ptrFromHandle_expr_Type_ListType(h CGoHandle) *expr.Type_ListType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_ListType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_ListType{})).(*expr.Type_ListType)
}
func handleFromPtr_expr_Type_ListType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_ListType", p))
}

// Converters for non-pointer handles for type: *expr.Type_MapType
func ptrFromHandle_expr_Type_MapType(h CGoHandle) *expr.Type_MapType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*expr.Type_MapType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(expr.Type_MapType{})).(*expr.Type_MapType)
}
func handleFromPtr_expr_Type_MapType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*expr.Type_MapType", p))
}

// Converters for pointer handles for type: protoreflect.EnumDescriptor
func ptrFromHandle_protoreflect_EnumDescriptor(h CGoHandle) protoreflect.EnumDescriptor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "protoreflect.EnumDescriptor")
	if p == nil {
		return nil
	}
	return p.(protoreflect.EnumDescriptor)
}
func handleFromPtr_protoreflect_EnumDescriptor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("protoreflect.EnumDescriptor", p))
}

// Converters for pointer handles for type: protoreflect.EnumType
func ptrFromHandle_protoreflect_EnumType(h CGoHandle) protoreflect.EnumType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "protoreflect.EnumType")
	if p == nil {
		return nil
	}
	return p.(protoreflect.EnumType)
}
func handleFromPtr_protoreflect_EnumType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("protoreflect.EnumType", p))
}

// Converters for pointer handles for type: protoreflect.Message
func ptrFromHandle_protoreflect_Message(h CGoHandle) protoreflect.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "protoreflect.Message")
	if p == nil {
		return nil
	}
	return p.(protoreflect.Message)
}
func handleFromPtr_protoreflect_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("protoreflect.Message", p))
}

// Converters for non-pointer handles for type: *durationpb.Duration
func ptrFromHandle_durationpb_Duration(h CGoHandle) *durationpb.Duration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*durationpb.Duration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(durationpb.Duration{})).(*durationpb.Duration)
}
func handleFromPtr_durationpb_Duration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*durationpb.Duration", p))
}

// Converters for non-pointer handles for type: *emptypb.Empty
func ptrFromHandle_emptypb_Empty(h CGoHandle) *emptypb.Empty {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*emptypb.Empty")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(emptypb.Empty{})).(*emptypb.Empty)
}
func handleFromPtr_emptypb_Empty(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*emptypb.Empty", p))
}

// Converters for non-pointer handles for type: *timestamppb.Timestamp
func ptrFromHandle_timestamppb_Timestamp(h CGoHandle) *timestamppb.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*timestamppb.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(timestamppb.Timestamp{})).(*timestamppb.Timestamp)
}
func handleFromPtr_timestamppb_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*timestamppb.Timestamp", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for non-pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := *ptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := *ptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for non-pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := *ptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := *ptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := *ptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := *ptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for non-pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := *ptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := *ptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for non-pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := *ptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := *ptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for non-pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := *ptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := *ptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for non-pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := *ptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := *ptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for non-pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := *ptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := *ptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for non-pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := *ptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := *ptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for non-pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := *ptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := *ptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for non-pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := *ptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := *ptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for non-pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := *ptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := *ptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for non-pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := *ptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := *ptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for non-pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := *ptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := *ptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for non-pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := *ptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := *ptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for non-pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := *ptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := *ptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: cel ---

// ---- Types ---

// Converters for pointer handles for type: *cel.Ast
func ptrFromHandle_Ptr_cel_Ast(h CGoHandle) *cel.Ast {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*cel.Ast")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Ast{})).(*cel.Ast)
}
func handleFromPtr_Ptr_cel_Ast(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*cel.Ast", p))
}

// Converters for pointer handles for type: *cel.Env
func ptrFromHandle_Ptr_cel_Env(h CGoHandle) *cel.Env {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*cel.Env")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Env{})).(*cel.Env)
}
func handleFromPtr_Ptr_cel_Env(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*cel.Env", p))
}

// Converters for pointer handles for type: *cel.EvalDetails
func ptrFromHandle_Ptr_cel_EvalDetails(h CGoHandle) *cel.EvalDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*cel.EvalDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.EvalDetails{})).(*cel.EvalDetails)
}
func handleFromPtr_Ptr_cel_EvalDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*cel.EvalDetails", p))
}

// Converters for pointer handles for type: *cel.Issues
func ptrFromHandle_Ptr_cel_Issues(h CGoHandle) *cel.Issues {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*cel.Issues")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Issues{})).(*cel.Issues)
}
func handleFromPtr_Ptr_cel_Issues(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*cel.Issues", p))
}

// Converters for non-pointer handles for type: []*interpreter.AttributeQualifierPattern
func ptrFromHandle_Slice_Ptr_interpreter_AttributeQualifierPattern(h CGoHandle) *[]*interpreter.AttributeQualifierPattern {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*interpreter.AttributeQualifierPattern")
	if p == nil {
		return nil
	}
	return p.(*[]*interpreter.AttributeQualifierPattern)
}
func handleFromPtr_Slice_Ptr_interpreter_AttributeQualifierPattern(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*interpreter.AttributeQualifierPattern", p))
}

// --- wrapping slice: []*interpreter.AttributeQualifierPattern ---
//export Slice_Ptr_interpreter_AttributeQualifierPattern_CTor
func Slice_Ptr_interpreter_AttributeQualifierPattern_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_interpreter_AttributeQualifierPattern(&[]*interpreter.AttributeQualifierPattern{}))
}

//export Slice_Ptr_interpreter_AttributeQualifierPattern_len
func Slice_Ptr_interpreter_AttributeQualifierPattern_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_Ptr_interpreter_AttributeQualifierPattern(handle))
}

//export Slice_Ptr_interpreter_AttributeQualifierPattern_elem
func Slice_Ptr_interpreter_AttributeQualifierPattern_elem(handle CGoHandle, _idx int) CGoHandle {
	s := *ptrFromHandle_Slice_Ptr_interpreter_AttributeQualifierPattern(handle)
	return handleFromPtr_Ptr_interpreter_AttributeQualifierPattern(s[_idx])
}

//export Slice_Ptr_interpreter_AttributeQualifierPattern_set
func Slice_Ptr_interpreter_AttributeQualifierPattern_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := *ptrFromHandle_Slice_Ptr_interpreter_AttributeQualifierPattern(handle)
	s[_idx] = ptrFromHandle_Ptr_interpreter_AttributeQualifierPattern(_vl)
}

//export Slice_Ptr_interpreter_AttributeQualifierPattern_append
func Slice_Ptr_interpreter_AttributeQualifierPattern_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_interpreter_AttributeQualifierPattern(handle)
	*s = append(*s, ptrFromHandle_Ptr_interpreter_AttributeQualifierPattern(_vl))
}

// Converters for non-pointer handles for type: []*expr.Expr
func ptrFromHandle_Slice_Ptr_expr_Expr(h CGoHandle) *[]*expr.Expr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*expr.Expr")
	if p == nil {
		return nil
	}
	return p.(*[]*expr.Expr)
}
func handleFromPtr_Slice_Ptr_expr_Expr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*expr.Expr", p))
}

// --- wrapping slice: []*expr.Expr ---
//export Slice_Ptr_expr_Expr_CTor
func Slice_Ptr_expr_Expr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_expr_Expr(&[]*expr.Expr{}))
}

//export Slice_Ptr_expr_Expr_len
func Slice_Ptr_expr_Expr_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_Ptr_expr_Expr(handle))
}

//export Slice_Ptr_expr_Expr_elem
func Slice_Ptr_expr_Expr_elem(handle CGoHandle, _idx int) CGoHandle {
	s := *ptrFromHandle_Slice_Ptr_expr_Expr(handle)
	return handleFromPtr_Ptr_expr_Expr(s[_idx])
}

//export Slice_Ptr_expr_Expr_set
func Slice_Ptr_expr_Expr_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := *ptrFromHandle_Slice_Ptr_expr_Expr(handle)
	s[_idx] = ptrFromHandle_Ptr_expr_Expr(_vl)
}

//export Slice_Ptr_expr_Expr_append
func Slice_Ptr_expr_Expr_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_expr_Expr(handle)
	*s = append(*s, ptrFromHandle_Ptr_expr_Expr(_vl))
}

// Converters for non-pointer handles for type: []*expr.Expr_CreateStruct_Entry
func ptrFromHandle_Slice_Ptr_expr_Expr_CreateStruct_Entry(h CGoHandle) *[]*expr.Expr_CreateStruct_Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*expr.Expr_CreateStruct_Entry")
	if p == nil {
		return nil
	}
	return p.(*[]*expr.Expr_CreateStruct_Entry)
}
func handleFromPtr_Slice_Ptr_expr_Expr_CreateStruct_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*expr.Expr_CreateStruct_Entry", p))
}

// --- wrapping slice: []*expr.Expr_CreateStruct_Entry ---
//export Slice_Ptr_expr_Expr_CreateStruct_Entry_CTor
func Slice_Ptr_expr_Expr_CreateStruct_Entry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_expr_Expr_CreateStruct_Entry(&[]*expr.Expr_CreateStruct_Entry{}))
}

//export Slice_Ptr_expr_Expr_CreateStruct_Entry_len
func Slice_Ptr_expr_Expr_CreateStruct_Entry_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_Ptr_expr_Expr_CreateStruct_Entry(handle))
}

//export Slice_Ptr_expr_Expr_CreateStruct_Entry_elem
func Slice_Ptr_expr_Expr_CreateStruct_Entry_elem(handle CGoHandle, _idx int) CGoHandle {
	s := *ptrFromHandle_Slice_Ptr_expr_Expr_CreateStruct_Entry(handle)
	return handleFromPtr_Ptr_expr_Expr_CreateStruct_Entry(s[_idx])
}

//export Slice_Ptr_expr_Expr_CreateStruct_Entry_set
func Slice_Ptr_expr_Expr_CreateStruct_Entry_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := *ptrFromHandle_Slice_Ptr_expr_Expr_CreateStruct_Entry(handle)
	s[_idx] = ptrFromHandle_Ptr_expr_Expr_CreateStruct_Entry(_vl)
}

//export Slice_Ptr_expr_Expr_CreateStruct_Entry_append
func Slice_Ptr_expr_Expr_CreateStruct_Entry_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_expr_Expr_CreateStruct_Entry(handle)
	*s = append(*s, ptrFromHandle_Ptr_expr_Expr_CreateStruct_Entry(_vl))
}

// Converters for non-pointer handles for type: []*expr.Type
func ptrFromHandle_Slice_Ptr_expr_Type(h CGoHandle) *[]*expr.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*expr.Type")
	if p == nil {
		return nil
	}
	return p.(*[]*expr.Type)
}
func handleFromPtr_Slice_Ptr_expr_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*expr.Type", p))
}

// --- wrapping slice: []*expr.Type ---
//export Slice_Ptr_expr_Type_CTor
func Slice_Ptr_expr_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_expr_Type(&[]*expr.Type{}))
}

//export Slice_Ptr_expr_Type_len
func Slice_Ptr_expr_Type_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_Ptr_expr_Type(handle))
}

//export Slice_Ptr_expr_Type_elem
func Slice_Ptr_expr_Type_elem(handle CGoHandle, _idx int) CGoHandle {
	s := *ptrFromHandle_Slice_Ptr_expr_Type(handle)
	return handleFromPtr_Ptr_expr_Type(s[_idx])
}

//export Slice_Ptr_expr_Type_set
func Slice_Ptr_expr_Type_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := *ptrFromHandle_Slice_Ptr_expr_Type(handle)
	s[_idx] = ptrFromHandle_Ptr_expr_Type(_vl)
}

//export Slice_Ptr_expr_Type_append
func Slice_Ptr_expr_Type_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_expr_Type(handle)
	*s = append(*s, ptrFromHandle_Ptr_expr_Type(_vl))
}

// Converters for non-pointer handles for type: []common.Error
func ptrFromHandle_Slice_common_Error(h CGoHandle) *[]common.Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]common.Error")
	if p == nil {
		return nil
	}
	return p.(*[]common.Error)
}
func handleFromPtr_Slice_common_Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]common.Error", p))
}

// --- wrapping slice: []common.Error ---
//export Slice_common_Error_CTor
func Slice_common_Error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_common_Error(&[]common.Error{}))
}

//export Slice_common_Error_len
func Slice_common_Error_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Slice_common_Error(handle))
}

//export Slice_common_Error_elem
func Slice_common_Error_elem(handle CGoHandle, _idx int) CGoHandle {
	s := *ptrFromHandle_Slice_common_Error(handle)
	return handleFromPtr_common_Error(s[_idx])
}

//export Slice_common_Error_set
func Slice_common_Error_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := *ptrFromHandle_Slice_common_Error(handle)
	s[_idx] = *ptrFromHandle_common_Error(_vl)
}

//export Slice_common_Error_append
func Slice_common_Error_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_common_Error(handle)
	*s = append(*s, *ptrFromHandle_common_Error(_vl))
}

// Converters for non-pointer handles for type: cel.Ast
func ptrFromHandle_cel_Ast(h CGoHandle) *cel.Ast {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Ast")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Ast{})).(*cel.Ast)
}
func handleFromPtr_cel_Ast(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Ast", p))
}

// Converters for non-pointer handles for type: cel.Env
func ptrFromHandle_cel_Env(h CGoHandle) *cel.Env {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Env")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Env{})).(*cel.Env)
}
func handleFromPtr_cel_Env(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Env", p))
}

// Converters for non-pointer handles for type: cel.EvalDetails
func ptrFromHandle_cel_EvalDetails(h CGoHandle) *cel.EvalDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.EvalDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.EvalDetails{})).(*cel.EvalDetails)
}
func handleFromPtr_cel_EvalDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.EvalDetails", p))
}

// Converters for non-pointer handles for type: cel.Issues
func ptrFromHandle_cel_Issues(h CGoHandle) *cel.Issues {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Issues")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(cel.Issues{})).(*cel.Issues)
}
func handleFromPtr_cel_Issues(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Issues", p))
}

// Converters for pointer handles for type: cel.Library
func ptrFromHandle_cel_Library(h CGoHandle) cel.Library {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Library")
	if p == nil {
		return nil
	}
	return p.(cel.Library)
}
func handleFromPtr_cel_Library(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Library", p))
}

// Converters for pointer handles for type: cel.Program
func ptrFromHandle_cel_Program(h CGoHandle) cel.Program {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Program")
	if p == nil {
		return nil
	}
	return p.(cel.Program)
}
func handleFromPtr_cel_Program(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Program", p))
}

// Converters for pointer handles for type: cel.Source
func ptrFromHandle_cel_Source(h CGoHandle) cel.Source {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cel.Source")
	if p == nil {
		return nil
	}
	return p.(cel.Source)
}
func handleFromPtr_cel_Source(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cel.Source", p))
}

// Converters for non-pointer handles for type: map[int64]*expr.Expr
func ptrFromHandle_Map_int64_Ptr_expr_Expr(h CGoHandle) *map[int64]*expr.Expr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int64]*expr.Expr")
	if p == nil {
		return nil
	}
	return p.(*map[int64]*expr.Expr)
}
func handleFromPtr_Map_int64_Ptr_expr_Expr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int64]*expr.Expr", p))
}

// --- wrapping map: map[int64]*expr.Expr ---
//export Map_int64_Ptr_expr_Expr_CTor
func Map_int64_Ptr_expr_Expr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int64_Ptr_expr_Expr(&map[int64]*expr.Expr{}))
}

//export Map_int64_Ptr_expr_Expr_len
func Map_int64_Ptr_expr_Expr_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Map_int64_Ptr_expr_Expr(handle))
}

//export Map_int64_Ptr_expr_Expr_elem
func Map_int64_Ptr_expr_Expr_elem(handle CGoHandle, _ky C.longlong) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Expr(handle)
	v, ok := s[int64(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_expr_Expr(v)
}

//export Map_int64_Ptr_expr_Expr_contains
func Map_int64_Ptr_expr_Expr_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Expr(handle)
	_, ok := s[int64(_ky)]
	return boolGoToPy(ok)
}

//export Map_int64_Ptr_expr_Expr_set
func Map_int64_Ptr_expr_Expr_set(handle CGoHandle, _ky C.longlong, _vl CGoHandle) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Expr(handle)
	s[int64(_ky)] = ptrFromHandle_Ptr_expr_Expr(_vl)
}

//export Map_int64_Ptr_expr_Expr_delete
func Map_int64_Ptr_expr_Expr_delete(handle CGoHandle, _ky C.longlong) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Expr(handle)
	delete(s, int64(_ky))
}

//export Map_int64_Ptr_expr_Expr_keys
func Map_int64_Ptr_expr_Expr_keys(handle CGoHandle) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Expr(handle)
	kys := make([]int64, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int64(&kys)
}

// Converters for non-pointer handles for type: map[int64]*expr.Reference
func ptrFromHandle_Map_int64_Ptr_expr_Reference(h CGoHandle) *map[int64]*expr.Reference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int64]*expr.Reference")
	if p == nil {
		return nil
	}
	return p.(*map[int64]*expr.Reference)
}
func handleFromPtr_Map_int64_Ptr_expr_Reference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int64]*expr.Reference", p))
}

// --- wrapping map: map[int64]*expr.Reference ---
//export Map_int64_Ptr_expr_Reference_CTor
func Map_int64_Ptr_expr_Reference_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int64_Ptr_expr_Reference(&map[int64]*expr.Reference{}))
}

//export Map_int64_Ptr_expr_Reference_len
func Map_int64_Ptr_expr_Reference_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Map_int64_Ptr_expr_Reference(handle))
}

//export Map_int64_Ptr_expr_Reference_elem
func Map_int64_Ptr_expr_Reference_elem(handle CGoHandle, _ky C.longlong) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Reference(handle)
	v, ok := s[int64(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_expr_Reference(v)
}

//export Map_int64_Ptr_expr_Reference_contains
func Map_int64_Ptr_expr_Reference_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Reference(handle)
	_, ok := s[int64(_ky)]
	return boolGoToPy(ok)
}

//export Map_int64_Ptr_expr_Reference_set
func Map_int64_Ptr_expr_Reference_set(handle CGoHandle, _ky C.longlong, _vl CGoHandle) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Reference(handle)
	s[int64(_ky)] = ptrFromHandle_Ptr_expr_Reference(_vl)
}

//export Map_int64_Ptr_expr_Reference_delete
func Map_int64_Ptr_expr_Reference_delete(handle CGoHandle, _ky C.longlong) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Reference(handle)
	delete(s, int64(_ky))
}

//export Map_int64_Ptr_expr_Reference_keys
func Map_int64_Ptr_expr_Reference_keys(handle CGoHandle) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Reference(handle)
	kys := make([]int64, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int64(&kys)
}

// Converters for non-pointer handles for type: map[int64]*expr.Type
func ptrFromHandle_Map_int64_Ptr_expr_Type(h CGoHandle) *map[int64]*expr.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int64]*expr.Type")
	if p == nil {
		return nil
	}
	return p.(*map[int64]*expr.Type)
}
func handleFromPtr_Map_int64_Ptr_expr_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int64]*expr.Type", p))
}

// --- wrapping map: map[int64]*expr.Type ---
//export Map_int64_Ptr_expr_Type_CTor
func Map_int64_Ptr_expr_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int64_Ptr_expr_Type(&map[int64]*expr.Type{}))
}

//export Map_int64_Ptr_expr_Type_len
func Map_int64_Ptr_expr_Type_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Map_int64_Ptr_expr_Type(handle))
}

//export Map_int64_Ptr_expr_Type_elem
func Map_int64_Ptr_expr_Type_elem(handle CGoHandle, _ky C.longlong) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Type(handle)
	v, ok := s[int64(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_expr_Type(v)
}

//export Map_int64_Ptr_expr_Type_contains
func Map_int64_Ptr_expr_Type_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Type(handle)
	_, ok := s[int64(_ky)]
	return boolGoToPy(ok)
}

//export Map_int64_Ptr_expr_Type_set
func Map_int64_Ptr_expr_Type_set(handle CGoHandle, _ky C.longlong, _vl CGoHandle) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Type(handle)
	s[int64(_ky)] = ptrFromHandle_Ptr_expr_Type(_vl)
}

//export Map_int64_Ptr_expr_Type_delete
func Map_int64_Ptr_expr_Type_delete(handle CGoHandle, _ky C.longlong) {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Type(handle)
	delete(s, int64(_ky))
}

//export Map_int64_Ptr_expr_Type_keys
func Map_int64_Ptr_expr_Type_keys(handle CGoHandle) CGoHandle {
	s := *ptrFromHandle_Map_int64_Ptr_expr_Type(handle)
	kys := make([]int64, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int64(&kys)
}

// Converters for non-pointer handles for type: map[int64]int32
func ptrFromHandle_Map_int64_int32(h CGoHandle) *map[int64]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int64]int32")
	if p == nil {
		return nil
	}
	return p.(*map[int64]int32)
}
func handleFromPtr_Map_int64_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int64]int32", p))
}

// --- wrapping map: map[int64]int32 ---
//export Map_int64_int32_CTor
func Map_int64_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int64_int32(&map[int64]int32{}))
}

//export Map_int64_int32_len
func Map_int64_int32_len(handle CGoHandle) int {
	return len(*ptrFromHandle_Map_int64_int32(handle))
}

//export Map_int64_int32_elem
func Map_int64_int32_elem(handle CGoHandle, _ky C.longlong) C.long {
	s := *ptrFromHandle_Map_int64_int32(handle)
	v, ok := s[int64(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.long(v)
}

//export Map_int64_int32_contains
func Map_int64_int32_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := *ptrFromHandle_Map_int64_int32(handle)
	_, ok := s[int64(_ky)]
	return boolGoToPy(ok)
}

//export Map_int64_int32_set
func Map_int64_int32_set(handle CGoHandle, _ky C.longlong, _vl C.long) {
	s := *ptrFromHandle_Map_int64_int32(handle)
	s[int64(_ky)] = int32(_vl)
}

//export Map_int64_int32_delete
func Map_int64_int32_delete(handle CGoHandle, _ky C.longlong) {
	s := *ptrFromHandle_Map_int64_int32(handle)
	delete(s, int64(_ky))
}

//export Map_int64_int32_keys
func Map_int64_int32_keys(handle CGoHandle) CGoHandle {
	s := *ptrFromHandle_Map_int64_int32(handle)
	kys := make([]int64, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int64(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export cel_Source_Content
func cel_Source_Content(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "cel.Source")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(cel.Source).Content())

}

//export cel_Source_Description
func cel_Source_Description(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "cel.Source")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(cel.Source).Description())

}

//export cel_Source_LineOffsets
func cel_Source_LineOffsets(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "cel.Source")
	if __err != nil {
		return handleFromPtr_Slice_int32(nil)
	}
	cret := vifc.(cel.Source).LineOffsets()

	return handleFromPtr_Slice_int32(&cret)
}

//export cel_Source_NewLocation
func cel_Source_NewLocation(_handle CGoHandle, line C.longlong, col C.longlong) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "cel.Source")
	if __err != nil {
		return handleFromPtr_common_Location(nil)
	}
	return handleFromPtr_common_Location(vifc.(cel.Source).NewLocation(int(line), int(col)))

}

// ---- Structs ---

// --- wrapping struct: cel.EvalDetails ---
//export cel_EvalDetails_CTor
func cel_EvalDetails_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_cel_EvalDetails(&cel.EvalDetails{}))
}

//export cel_EvalDetails_State
func cel_EvalDetails_State(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.EvalDetails")
	if __err != nil {
		return handleFromPtr_interpreter_EvalState(nil)
	}
	return handleFromPtr_interpreter_EvalState(gopyh.Embed(vifc, reflect.TypeOf(cel.EvalDetails{})).(*cel.EvalDetails).State())

}

// --- wrapping struct: cel.Issues ---
//export cel_Issues_CTor
func cel_Issues_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_cel_Issues(&cel.Issues{}))
}

//export cel_Issues_Err
func cel_Issues_Err(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Issues")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(cel.Issues{})).(*cel.Issues).Err()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export cel_Issues_Errors
func cel_Issues_Errors(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Issues")
	if __err != nil {
		return handleFromPtr_Slice_common_Error(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(cel.Issues{})).(*cel.Issues).Errors()

	return handleFromPtr_Slice_common_Error(&cret)
}

//export cel_Issues_Append
func cel_Issues_Append(_handle CGoHandle, other CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Issues")
	if __err != nil {
		return handleFromPtr_Ptr_cel_Issues(nil)
	}
	return handleFromPtr_Ptr_cel_Issues(gopyh.Embed(vifc, reflect.TypeOf(cel.Issues{})).(*cel.Issues).Append(ptrFromHandle_Ptr_cel_Issues(other)))

}

//export cel_Issues_String
func cel_Issues_String(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Issues")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(cel.Issues{})).(*cel.Issues).String())

}

// --- wrapping struct: cel.Ast ---
//export cel_Ast_CTor
func cel_Ast_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_cel_Ast(&cel.Ast{}))
}

//export cel_Ast_Expr
func cel_Ast_Expr(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Ast")
	if __err != nil {
		return handleFromPtr_Ptr_expr_Expr(nil)
	}
	return handleFromPtr_Ptr_expr_Expr(gopyh.Embed(vifc, reflect.TypeOf(cel.Ast{})).(*cel.Ast).Expr())

}

//export cel_Ast_IsChecked
func cel_Ast_IsChecked(_handle CGoHandle) C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Ast")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(cel.Ast{})).(*cel.Ast).IsChecked())

}

//export cel_Ast_SourceInfo
func cel_Ast_SourceInfo(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Ast")
	if __err != nil {
		return handleFromPtr_Ptr_expr_SourceInfo(nil)
	}
	return handleFromPtr_Ptr_expr_SourceInfo(gopyh.Embed(vifc, reflect.TypeOf(cel.Ast{})).(*cel.Ast).SourceInfo())

}

//export cel_Ast_ResultType
func cel_Ast_ResultType(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Ast")
	if __err != nil {
		return handleFromPtr_Ptr_expr_Type(nil)
	}
	return handleFromPtr_Ptr_expr_Type(gopyh.Embed(vifc, reflect.TypeOf(cel.Ast{})).(*cel.Ast).ResultType())

}

//export cel_Ast_Source
func cel_Ast_Source(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Ast")
	if __err != nil {
		return handleFromPtr_cel_Source(nil)
	}
	return handleFromPtr_cel_Source(gopyh.Embed(vifc, reflect.TypeOf(cel.Ast{})).(*cel.Ast).Source())

}

// --- wrapping struct: cel.Env ---
//export cel_Env_CTor
func cel_Env_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_cel_Env(&cel.Env{}))
}

//export cel_Env_HasFeature
func cel_Env_HasFeature(_handle CGoHandle, flag C.longlong) C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).HasFeature(int(flag)))

}

//export cel_Env_SetFeature
func cel_Env_SetFeature(_handle CGoHandle, flag C.longlong, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).SetFeature(int(flag))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).SetFeature(int(flag))
	}
}

//export cel_Env_TypeAdapter
func cel_Env_TypeAdapter(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return handleFromPtr_ref_TypeAdapter(nil)
	}
	return handleFromPtr_ref_TypeAdapter(gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).TypeAdapter())

}

//export cel_Env_TypeProvider
func cel_Env_TypeProvider(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return handleFromPtr_ref_TypeProvider(nil)
	}
	return handleFromPtr_ref_TypeProvider(gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).TypeProvider())

}

//export cel_Env_UnknownVars
func cel_Env_UnknownVars(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return handleFromPtr_interpreter_PartialActivation(nil)
	}
	return handleFromPtr_interpreter_PartialActivation(gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).UnknownVars())

}

//export cel_Env_ResidualAst
func cel_Env_ResidualAst(_handle CGoHandle, a CGoHandle, details CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*cel.Env")
	if __err != nil {
		return handleFromPtr_Ptr_cel_Ast(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(cel.Env{})).(*cel.Env).ResidualAst(ptrFromHandle_Ptr_cel_Ast(a), ptrFromHandle_Ptr_cel_EvalDetails(details))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
	}
	return handleFromPtr_Ptr_cel_Ast(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export cel_NewIssues
func cel_NewIssues(errs CGoHandle) CGoHandle {
	return handleFromPtr_Ptr_cel_Issues(cel.NewIssues(ptrFromHandle_Ptr_common_Errors(errs)))

}

//export cel_ParsedExprToAst
func cel_ParsedExprToAst(parsedExpr CGoHandle) CGoHandle {
	return handleFromPtr_Ptr_cel_Ast(cel.ParsedExprToAst(ptrFromHandle_Ptr_expr_ParsedExpr(parsedExpr)))

}

//export cel_CheckedExprToAst
func cel_CheckedExprToAst(checkedExpr CGoHandle) CGoHandle {
	return handleFromPtr_Ptr_cel_Ast(cel.CheckedExprToAst(ptrFromHandle_Ptr_expr_CheckedExpr(checkedExpr)))

}

// ---- Functions ---

//export cel_AstToString
func cel_AstToString(a CGoHandle) *C.char {
	cret, __err := cel.AstToString(ptrFromHandle_Ptr_cel_Ast(a))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
	}
	return C.CString(cret)
}

//export cel_AttributePattern
func cel_AttributePattern(varName *C.char) CGoHandle {
	return handleFromPtr_Ptr_interpreter_AttributePattern(cel.AttributePattern(C.GoString(varName)))

}

//export cel_NoVars
func cel_NoVars() CGoHandle {
	return handleFromPtr_interpreter_Activation(cel.NoVars())

}

//export cel_AstToCheckedExpr
func cel_AstToCheckedExpr(a CGoHandle) CGoHandle {
	cret, __err := cel.AstToCheckedExpr(ptrFromHandle_Ptr_cel_Ast(a))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
	}
	return handleFromPtr_Ptr_expr_CheckedExpr(cret)
}

//export cel_AstToParsedExpr
func cel_AstToParsedExpr(a CGoHandle) CGoHandle {
	cret, __err := cel.AstToParsedExpr(ptrFromHandle_Ptr_cel_Ast(a))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
	}
	return handleFromPtr_Ptr_expr_ParsedExpr(cret)
}
